{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Code/japanese-learning/lib/google-ai.ts"],"sourcesContent":["import { GoogleGenerativeAI } from \"@google/generative-ai\";\nimport { KanjiItem, VocabularyItem } from \"@/types\";\n\n// Initialize Google AI API key\nconst apiKey = process.env.GOOGLE_AI_API_KEY!;\n// Keep the SDK initialization for compatibility\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst genAI = new GoogleGenerativeAI(apiKey);\n\n// Update to use Gemini 2.0-flash model\nconst MODEL_NAME = \"gemini-2.0-flash\";\n\n// Base URL for direct API calls\nconst API_BASE_URL = \"https://generativelanguage.googleapis.com/v1beta\";\n\n// Direct API call helper function - FIXED to match exact API format\nasync function callGeminiAPI(prompt: string, imageData?: string): Promise<string> {\n  // Define types for Gemini API request parts\n  type TextPart = { text: string };\n  type ImagePart = { inlineData: { mimeType: string; data: string } };\n  type GeminiPart = TextPart | ImagePart;\n  \n  // Prepare the endpoint URL\n  const endpoint = `${API_BASE_URL}/models/${MODEL_NAME}:generateContent?key=${apiKey}`;\n  \n  // Prepare the request parts according to Gemini API format\n  const parts: GeminiPart[] = [{ text: prompt }];\n  \n  // Add image data if provided - FIXED format for inline_data\n  if (imageData) {\n    const base64Data = imageData.replace(/^data:image\\/(png|jpeg|jpg);base64,/, '');\n    const mimeType = imageData.startsWith('data:image/jpeg') ? 'image/jpeg' : \n                     imageData.startsWith('data:image/jpg') ? 'image/jpg' : 'image/png';\n                    \n    parts.push({\n      inlineData: { // FIXED: Changed from inline_data to inlineData\n        mimeType: mimeType, // FIXED: Changed from mime_type to mimeType\n        data: base64Data\n      }\n    });\n  }\n  \n  // Thiết lập cấu hình riêng cho nhận dạng hình ảnh\n  const generationConfig = imageData ? {\n    temperature: 0.01, // Giảm temperature xuống rất thấp để nhận diện chính xác hơn\n    topP: 0.90,\n    topK: 10,\n    maxOutputTokens: 2048,\n  } : {\n    temperature: 0.05,\n    topP: 0.95, \n    topK: 16,\n    maxOutputTokens: 2048,\n  };\n  \n  // FIXED: Prepare the request body according to the exact API format\n  const requestBody = {\n    contents: [{\n      parts: parts\n    }],\n    generationConfig: generationConfig,\n    safetySettings: [\n      {\n        category: \"HARM_CATEGORY_HARASSMENT\",\n        threshold: \"BLOCK_MEDIUM_AND_ABOVE\"\n      },\n      {\n        category: \"HARM_CATEGORY_HATE_SPEECH\",\n        threshold: \"BLOCK_MEDIUM_AND_ABOVE\"\n      }\n    ]\n  };\n\n  try {\n    console.log(\"Sending direct API request to Gemini...\");\n    \n    const response = await fetch(endpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(requestBody),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.text();\n      console.error(\"Gemini API error:\", errorData);\n      throw new Error(`API call failed: ${response.status} ${response.statusText} - ${errorData}`);\n    }\n\n    const data = await response.json();\n    \n    // FIXED: Improved response validation\n    if (!data.candidates || data.candidates.length === 0) {\n      console.error(\"Empty response from Gemini API:\", data);\n      throw new Error(\"No candidates in Gemini API response\");\n    }\n    \n    const candidate = data.candidates[0];\n    \n    // Check for finish reason other than STOP\n    if (candidate.finishReason && candidate.finishReason !== \"STOP\") {\n      console.warn(`Gemini API finished with reason: ${candidate.finishReason}`);\n      if (candidate.finishReason === \"SAFETY\") {\n        throw new Error(\"Content blocked by safety settings\");\n      }\n    }\n    \n    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {\n      console.error(\"Invalid content structure in response:\", candidate);\n      throw new Error(\"Invalid response structure from Gemini API\");\n    }\n    \n    // Define type for API response parts\n    type ApiResponsePart = {\n      text?: string;\n      [key: string]: unknown;\n    };\n    \n    // Extract text from all parts\n    const textParts = candidate.content.parts\n      .filter((part: ApiResponsePart) => part.text)\n      .map((part: ApiResponsePart) => part.text);\n    \n    if (textParts.length === 0) {\n      console.error(\"No text content in response:\", candidate.content);\n      throw new Error(\"No text content in Gemini API response\");\n    }\n    \n    return textParts.join(\"\");\n  } catch (error) {\n    console.error(\"Error calling Gemini API:\", error);\n    throw error;\n  }\n}\n\n// Improve JSON extraction function for better parsing\nfunction extractJsonFromText<T>(text: string): T {\n  // Loại bỏ các ký tự không cần thiết có thể gây lỗi parse\n  text = text.trim();\n  \n  // First try direct parsing\n  try {\n    return JSON.parse(text);\n  } catch {\n    console.log(\"Initial JSON parsing failed, trying to extract JSON...\");\n    \n    // Try to extract JSON from code blocks or find JSON pattern\n    const jsonMatch = \n      text.match(/```(?:json)?\\s*([\\s\\S]*?)\\s*```/) || \n      text.match(/({[\\s\\S]*})/);\n    \n    if (!jsonMatch) {\n      console.error(\"No JSON pattern found in response\");\n      throw new Error(\"Could not extract JSON from the response\");\n    }\n    \n    let jsonContent = jsonMatch[1] || jsonMatch[0];\n    jsonContent = jsonContent.trim();\n    \n    // Thử sửa lỗi JSON không hợp lệ\n    try {\n      return JSON.parse(jsonContent);\n    } catch {\n      console.log(\"JSON extraction failed, attempting to fix JSON...\");\n      \n      // Cố gắng sửa các lỗi phổ biến trong JSON\n      \n      // 1. Sửa dấu phẩy thừa ở cuối mảng/object\n      jsonContent = jsonContent.replace(/,(\\s*[}\\]])/g, '$1');\n      \n      // 2. Sửa dấu nháy không hợp lệ\n      jsonContent = jsonContent.replace(/(['\"])?([a-zA-Z0-9_]+)(['\"])?:/g, '\"$2\":');\n      \n      // 3. Thêm dấu nháy cho các giá trị chuỗi không có dấu nháy\n      jsonContent = jsonContent.replace(/:\\s*([^[{\"},\\s][^,}\\]]*?)([,}\\]])/g, ':\"$1\"$2');\n      \n      try {\n        const fixedJson = JSON.parse(jsonContent);\n        console.log(\"Successfully fixed JSON format\");\n        return fixedJson;\n      } catch (finalError) {\n        console.error(\"Failed to fix JSON format:\", finalError);\n        console.error(\"Problematic JSON string:\", jsonContent);\n        throw new Error(`Failed to parse extracted JSON after cleanup attempts: ${finalError instanceof Error ? finalError.message : \"Unknown error\"}`);\n      }\n    }\n  }\n}\n\n// Enhanced chatWithAI function with direct API calls\nexport async function chatWithAI(prompt: string, context: string = \"\"): Promise<string> {\n  try {\n    // Enhanced prompt with clear instructions\n    let fullPrompt;\n    if (context) {\n      fullPrompt = `You are a helpful Japanese language assistant. Respond in the same language the user is using.\n\nPrevious conversation:\n${context}\n\nNew message from user: ${prompt}\n\nGive a clear, accurate response without unnecessary explanations unless requested.`;\n    } else {\n      fullPrompt = `You are a helpful Japanese language assistant. Respond in the same language the user is using.\n\nMessage from user: ${prompt}\n\nGive a clear, accurate response without unnecessary explanations unless requested.`;\n    }\n\n    const response = await callGeminiAPI(fullPrompt);\n    return response;\n  } catch (error) {\n    console.error(\"Error chatting with AI:\", error);\n    throw new Error(`Failed to generate response from AI: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n  }\n}\n\n// Enhanced translation function with direct API calls\nexport async function translateText(\n  text: string, \n  sourceLang: string = \"en\", \n  targetLang: string = \"ja\"\n): Promise<string> {\n  try {\n    // Enhanced prompt with strict instructions\n    const prompt = `Translate the following text from ${sourceLang} to ${targetLang}.\n    \nInput text: \"${text}\"\n\nRules:\n1. Provide ONLY the translation, with no explanations or additional text\n2. Maintain the original tone and formality level\n3. Preserve proper names as they are unless they have standard translations\n4. Ensure natural sounding output in the target language\n\nTranslation:`;\n\n    const response = await callGeminiAPI(prompt);\n    return response.trim();\n  } catch (error) {\n    console.error(\"Error translating text:\", error);\n    throw new Error(\"Failed to translate text\");\n  }\n}\n\n// Kanji Analysis Type Definition\ninterface KanjiAnalysis {\n  character: string;\n  onReading: string[];\n  kunReading: string[];\n  meaning: string[];\n  strokeCount: number;\n  jlptLevel: string;\n  examples: {\n    word: string;\n    reading: string;\n    meaning: string;\n  }[];\n}\n\n// Enhanced kanji recognition function with direct API calls\nexport async function recognizeKanji(kanjiCharacter: string): Promise<KanjiAnalysis> {\n  try {\n    // Enhanced structured prompt with CORRECTED PROPERTY NAMES\n    const prompt = `Analyze this Japanese kanji character: ${kanjiCharacter}\n\nReturn ONLY a valid JSON object with EXACTLY this structure and nothing else:\n{\n  \"character\": \"${kanjiCharacter}\",\n  \"onReading\": [\"Array of ON readings in katakana\"],\n  \"kunReading\": [\"Array of KUN readings in hiragana\"],\n  \"meaning\": [\"Array of Vietnamese meanings\"],\n  \"strokeCount\": number,\n  \"jlptLevel\": \"N5/N4/N3/N2/N1\",\n  \"examples\": [\n    {\"word\": \"example compound word\", \"reading\": \"reading in hiragana\", \"meaning\": \"Vietnamese meaning\"},\n    {\"word\": \"example compound word\", \"reading\": \"reading in hiragana\", \"meaning\": \"Vietnamese meaning\"}\n  ]\n}\n\nInclude common and useful examples. Make sure all Japanese text is properly formatted with correct kana.\nDo not include any explanations or text outside the JSON object.`;\n\n    const jsonStr = await callGeminiAPI(prompt);\n    return extractJsonFromText<KanjiAnalysis>(jsonStr);\n  } catch (error) {\n    console.error(\"Error analyzing kanji:\", error);\n    throw new Error(\"Failed to analyze kanji\");\n  }\n}\n\n// Enhanced image recognition function using direct API calls\nexport async function recognizeKanjiFromImage(imageBase64: string): Promise<KanjiItem> {\n  try {\n    // Validate input\n    if (!imageBase64) {\n      throw new Error(\"No image data provided\");\n    }\n\n    // Validate that we have actual image data\n    if (!imageBase64.startsWith('data:image/')) {\n      throw new Error(\"Invalid image format. Expected data URL format.\");\n    }\n\n    console.log(`Processing image data of length: ${imageBase64.length}`);\n\n    // Enhanced prompt for more accurate kanji recognition with specific instructions\n    const prompt = `Bạn là một chuyên gia về nhận dạng chữ Kanji với độ chính xác cao. Hãy phân tích hình ảnh được cung cấp.\n\nNHIỆM VỤ CHÍNH: Nhận diện CHÍNH XÁC một ký tự Kanji duy nhất trong hình vẽ tay và cung cấp thông tin chi tiết.\n\nQuy trình phân tích (thực hiện nghiêm ngặt):\n1. Quan sát kỹ hình ảnh, tách biệt nét chữ khỏi nền\n2. Xem xét cấu trúc của các nét vẽ, thứ tự nét, và tỷ lệ giữa các phần\n3. Phân tích bộ thủ (radicals) để xác định chính xác ký tự Kanji\n4. Xác định một và CHỈ MỘT ký tự Kanji duy nhất\n5. Đối chiếu với từ điển kanji chuẩn để lấy thông tin chính xác\n\nCẢNH BÁO: Nhiều hệ thống AI có xu hướng nhận dạng sai ký tự Kanji, đặc biệt với chữ viết tay. Hãy đánh giá THẬN TRỌNG và so sánh với danh sách Kanji phổ biến.\n\nCHỈ trả về một đối tượng JSON hợp lệ với cấu trúc CHÍNH XÁC sau:\n{\n  \"character\": \"漢\", // MỘT ký tự Kanji duy nhất, đảm bảo là ký tự Kanji thực sự\n  \"onReading\": [\"カン\"], // âm ON trong katakana, đầy đủ và chính xác\n  \"kunReading\": [\"\"], // âm KUN trong hiragana, có thể trống nếu không có\n  \"meaning\": [\"Hán\", \"người Hán\", \"Trung Quốc\"], // nghĩa tiếng Việt đầy đủ\n  \"strokeCount\": 13, // số nét CHÍNH XÁC\n  \"jlptLevel\": \"N3\", // cấp độ JLPT chính xác (N5, N4, N3, N2, hoặc N1)\n  \"examples\": [\n    {\"word\": \"漢字\", \"reading\": \"かんじ\", \"meaning\": \"chữ Hán\"},\n    {\"word\": \"漢方\", \"reading\": \"かんぽう\", \"meaning\": \"y học cổ truyền Trung Quốc\"},\n    {\"word\": \"漢文\", \"reading\": \"かんぶん\", \"meaning\": \"văn ngôn Hán văn\"}\n  ]\n}\n\nQUY TẮC NGHIÊM NGẶT:\n- Ký tự trong trường \"character\" PHẢI nằm trong bảng mã kanji Unicode (CJK Unified Ideographs)\n- Thông tin âm đọc, nghĩa và số nét PHẢI CHÍNH XÁC theo từ điển chuẩn\n- Kiểm tra lại kỹ rằng ký tự được nhận dạng là kanji thực sự, không phải kana hoặc ký tự khác\n- Trường \"examples\" phải chứa các từ vựng thông dụng, thực tế có sử dụng ký tự kanji đó\n- KHÔNG bao gồm bất kỳ văn bản giải thích nào ngoài đối tượng JSON\n\nNếu HOÀN TOÀN không thể nhận ra chữ Kanji nào rõ ràng, hãy trả về kanji cơ bản N5 có cấu trúc nét tương tự nhất.`;\n\n    console.log(\"Sending kanji image to Gemini API...\");\n    \n    // Thiết lập tham số API với nhiệt độ thấp hơn để kết quả nhất quán\n    const textContent = await callGeminiAPI(prompt, imageBase64);\n    console.log(\"Response text length:\", textContent.length);\n    \n    // Xử lý JSON và kiểm tra kết quả\n    try {\n      const parsedData = extractJsonFromText<KanjiItem>(textContent);\n      \n      // Enhanced validation for the response structure\n      if (!parsedData || !parsedData.character) {\n        console.error(\"Invalid kanji data structure:\", parsedData);\n        throw new Error(\"Invalid kanji data: missing character\");\n      }\n      \n      // Validate that we're returning exactly one kanji character using strict Unicode range\n      if (parsedData.character.length !== 1 || !/[\\u4e00-\\u9faf]/.test(parsedData.character)) {\n        console.error(\"Invalid kanji character detected:\", parsedData.character);\n        throw new Error(\"Invalid kanji: The detected character is not a single valid kanji\");\n      }\n      \n      // Validate all required fields with strict checking\n      if (!Array.isArray(parsedData.onReading) || !parsedData.onReading.length) {\n        throw new Error(\"Invalid kanji data: missing onReading\");\n      }\n      \n      if (!Array.isArray(parsedData.kunReading)) {\n        throw new Error(\"Invalid kanji data: missing kunReading\");\n      }\n      \n      if (!Array.isArray(parsedData.meaning) || !parsedData.meaning.length) {\n        throw new Error(\"Invalid kanji data: missing meaning\");\n      }\n      \n      if (typeof parsedData.strokeCount !== 'number' || parsedData.strokeCount <= 0) {\n        throw new Error(\"Invalid kanji data: invalid strokeCount\");\n      }\n      \n      if (!parsedData.jlptLevel || !/^N[1-5]$/.test(parsedData.jlptLevel)) {\n        throw new Error(\"Invalid kanji data: invalid jlptLevel\");\n      }\n      \n      if (!Array.isArray(parsedData.examples) || parsedData.examples.length === 0) {\n        throw new Error(\"Invalid kanji data: missing examples\");\n      }\n      \n      // Validate format of each example\n      parsedData.examples.forEach((example, index) => {\n        if (!example.word || !example.reading || !example.meaning) {\n          throw new Error(`Invalid kanji data: missing properties in example ${index + 1}`);\n        }\n      });\n      \n      console.log(\"Successfully recognized kanji:\", parsedData.character);\n      return parsedData as KanjiItem;\n    } catch (parseError) {\n      console.error(\"JSON parsing error:\", parseError);\n      console.error(\"Raw response excerpt:\", textContent.substring(0, 200) + \"...\");\n      throw new Error(`Failed to parse AI response: ${parseError instanceof Error ? parseError.message : \"Unknown error\"}`);\n    }\n  } catch (error) {\n    console.error(\"Error recognizing kanji from image:\", error);\n    throw new Error(`Failed to analyze kanji image: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n  }\n}\n\n// Enhanced vocabulary generation with direct API calls\nexport async function generateVocabulary(\n  query: string = \"\", \n  level: string = \"N5\", \n  count: number = 6\n): Promise<VocabularyItem[]> {\n  try {\n    // Enhanced structured prompt\n    const prompt = `Generate ${count} accurate Japanese vocabulary items ${query ? \"related to '\" + query + \"'\" : \"\"} \nfor JLPT level ${level === \"all\" ? \"N5 to N1\" : level}.\n\nRESPONSE FORMAT: Return ONLY a valid JSON array with EXACTLY this structure:\n[\n  {\n    \"id\": \"1\",\n    \"japanese\": \"単語\",\n    \"hiragana\": \"たんご\",\n    \"romaji\": \"tango\",\n    \"meaning\": \"Precise Vietnamese translation\",\n    \"example\": {\n      \"japanese\": \"Natural Japanese example sentence with correct grammar\",\n      \"meaning\": \"Accurate Vietnamese translation of the example\"\n    },\n    \"level\": \"${level === \"all\" ? \"N5/N4/N3/N2/N1\" : level}\"\n  },\n  {... next item}\n]\n\nIMPORTANT RULES:\n1. Ensure all vocabulary is actually at the specified JLPT level\n2. Provide accurate hiragana readings and romaji\n3. Include natural, useful example sentences\n4. Ensure all Japanese text uses correct characters and grammar\n5. Maintain the exact JSON structure requested\n6. Return ONLY the JSON array, no explanations or additional text`;\n\n    const jsonStr = await callGeminiAPI(prompt);\n    return extractJsonFromText<VocabularyItem[]>(jsonStr);\n  } catch (error) {\n    console.error(\"Error generating vocabulary:\", error);\n    throw new Error(\"Failed to generate vocabulary data\");\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 436, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Code/japanese-learning/app/api/ai/recognize-kanji/route.ts"],"sourcesContent":["// app/api/ai/recognize-kanji/route.ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { recognizeKanjiFromImage } from \"@/lib/google-ai\";\nimport { z } from \"zod\";\nimport { KanjiItem } from \"@/types\";\n\nconst recognizeSchema = z.object({\n  image: z.string().min(1),\n});\n\n// Thiết lập timeout dài hơn cho nhận dạng kanji (30 giây)\nconst RECOGNITION_TIMEOUT_MS = 30000;\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    \n    // Validate request body\n    const validatedData = recognizeSchema.parse(body);\n    \n    // Check for valid image data\n    if (!validatedData.image || \n        !validatedData.image.startsWith('data:image/')) {\n      return NextResponse.json(\n        { \n          success: false,\n          error: \"Invalid image format. Expected data URL format.\" \n        },\n        { status: 400 }\n      );\n    }\n    \n    console.log(\"Processing kanji recognition request...\");\n    \n    // Tạo promise timeout để hủy nếu quá lâu\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error(\"Recognition request timed out\")), RECOGNITION_TIMEOUT_MS);\n    });\n    \n    // Chạy nhận diện với promise race\n    const kanjiData = await Promise.race<KanjiItem>([\n      recognizeKanjiFromImage(validatedData.image),\n      timeoutPromise\n    ]);\n    \n    // Validate response data structure\n    if (!kanjiData || !kanjiData.character) {\n      throw new Error(\"Invalid response from AI service\");\n    }\n    \n    console.log(\"Successfully recognized kanji:\", kanjiData.character);\n    \n    return NextResponse.json({ \n      success: true,\n      kanji: kanjiData \n    }, { status: 200 });\n  } catch (error) {\n    console.error(\"Kanji recognition error:\", error);\n    \n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { \n          success: false, \n          error: \"Invalid request data\", \n          details: error.errors \n        },\n        { status: 400 }\n      );\n    }\n    \n    // Handle specific errors more gracefully\n    const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n    \n    if (errorMessage.includes('timed out')) {\n      return NextResponse.json(\n        { \n          success: false, \n          error: 'Quá thời gian xử lý. Vui lòng thử lại với hình ảnh rõ ràng hơn.',\n          details: errorMessage\n        },\n        { status: 504 }\n      );\n    }\n    else if (errorMessage.includes('deprecated')) {\n      return NextResponse.json(\n        { \n          success: false, \n          error: 'AI model has been deprecated. Please contact admin for an update.',\n          details: errorMessage\n        },\n        { status: 500 }\n      );\n    } \n    else if (errorMessage.includes('Invalid image')) {\n      return NextResponse.json(\n        { \n          success: false, \n          error: errorMessage \n        },\n        { status: 400 }\n      );\n    }\n    else if (errorMessage.includes('parse')) {\n      return NextResponse.json(\n        { \n          success: false, \n          error: 'Failed to process the AI response',\n          details: errorMessage \n        },\n        { status: 500 }\n      );\n    }\n    else if (errorMessage.includes('Invalid kanji data')) {\n      return NextResponse.json(\n        { \n          success: false, \n          error: 'Invalid response format from AI service',\n          details: errorMessage \n        },\n        { status: 500 }\n      );\n    }\n    else if (errorMessage.includes('Invalid kanji')) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Không thể nhận dạng chữ Kanji hợp lệ. Vui lòng vẽ rõ ràng hơn.',\n          details: errorMessage\n        },\n        { status: 422 }\n      );\n    }\n    \n    return NextResponse.json(\n      { \n        success: false, \n        error: \"Failed to recognize kanji\", \n        details: errorMessage\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}